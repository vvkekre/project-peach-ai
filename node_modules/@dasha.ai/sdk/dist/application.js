"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Application = void 0;
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const audio = __importStar(require("./audio"));
const errors = __importStar(require("./errors"));
const grpc = __importStar(require("./grpc-api"));
const rest = __importStar(require("./rest-api"));
const stt = __importStar(require("./stt"));
const tts = __importStar(require("./tts"));
const zip = __importStar(require("./zip"));
const account_1 = require("./account");
const conversation_1 = require("./conversation");
const incoming_1 = require("./incoming");
const log_1 = require("./log");
const queue_1 = require("./queue");
// we can not import it in ts-style because the package is not into TS rootDir
// if you know
// eslint-disable-next-line @typescript-eslint/no-var-requires
const packageJson = require("../package.json");
const sdkVersion = `node:${(_a = packageJson.name) !== null && _a !== void 0 ? _a : "unknown"}@${(_b = packageJson.version) !== null && _b !== void 0 ? _b : "unknown"}`;
var ApplicationState;
(function (ApplicationState) {
    ApplicationState[ApplicationState["Initial"] = 0] = "Initial";
    ApplicationState[ApplicationState["Stopped"] = 1] = "Stopped";
    ApplicationState[ApplicationState["Running"] = 2] = "Running";
})(ApplicationState || (ApplicationState = {}));
// reference-style links don't seem to work here, for whatever reason
/**
 * A [DashaScript](https://docs.dasha.ai/en-us/default/dasha-script-language/)
 * conversational application {@link deploy | deployed} to the Dasha platform.
 *
 * @template TInput conversation input data type
 * @template TOutput conversation output data type
 */
class Application extends eventemitter3_1.default {
    constructor(options, applicationId, applicationName, instanceId, processingClient, instanceStream, inputSchema, outputSchema) {
        super();
        this._audioClientStreams = [];
        //#region lifecycle
        this._state = ApplicationState.Initial;
        this._concurrency = 0;
        //#endregion
        //#region stream reconnects
        this._healthcheck = () => __awaiter(this, void 0, void 0, function* () {
            const api = new rest.DiagnosticsApi(this.account, this.log);
            try {
                this.log.debug(`requesting a server healthcheck`);
                yield api.getInstanceLimits({ instanceId: this._instanceId });
                this.log.debug(`healthcheck ok`);
            }
            catch (error) {
                this.log.warn(`healthcheck found connection issues; trying to reconnect`);
                this.log.debug(error);
                if (this._healthcheckIntervalHandle) {
                    clearInterval(this._healthcheckIntervalHandle);
                    this._healthcheckIntervalHandle = undefined;
                }
                yield this._reconnect();
            }
        });
        this._handleStreamError = (error) => __awaiter(this, void 0, void 0, function* () {
            yield this._reconnect(error);
        });
        //#endregion
        //#region external call handlers
        // cannot type better because of variance problems
        // eslint-disable-next-line @typescript-eslint/ban-types
        this._externals = new Map();
        this._handleRpcRequest = (request) => __awaiter(this, void 0, void 0, function* () {
            const { jobId, requestId, method, parameters } = request;
            if (this._state !== ApplicationState.Running) {
                this.emit("error", log_1.logAndReturn(this.log, new errors.Error("application is not running")));
                this._processingClient
                    .sendRpcError({
                    instanceId: this._instanceId,
                    rpcError: { jobId, requestId, method, message: "application instance was not running" },
                })
                    .catch((error) => this.emit("error", error));
                return;
            }
            const conv = this._activeConversationsByJobId.get(jobId);
            if (conv === undefined) {
                this.emit("error", log_1.logAndReturn(this.log, new errors.InternalError()));
                this._processingClient
                    .sendRpcError({
                    instanceId: this._instanceId,
                    rpcError: { jobId, requestId, method, message: "internal error" },
                })
                    .catch((error) => this.emit("error", error));
            }
            const externalHandler = this._externals.get(method);
            if (externalHandler === undefined) {
                this.emit("error", log_1.logAndReturn(this.log, new errors.ExternalNotFoundError(method)));
                this._processingClient
                    .sendRpcError({
                    instanceId: this._instanceId,
                    rpcError: {
                        jobId,
                        requestId,
                        method,
                        message: `external function ${method} not found`,
                    },
                })
                    .catch((error) => this.emit("error", error));
                return;
            }
            let result;
            try {
                result = yield externalHandler(parameters, conv);
            }
            catch (error) {
                const errorMessage = (error === null || error === void 0 ? void 0 : error.message) ? String(error.message) : String(error);
                this.log.warn(`external function error: ${errorMessage}`, error);
                this._processingClient
                    .sendRpcError({
                    instanceId: this._instanceId,
                    rpcError: { jobId, requestId, method, message: errorMessage },
                })
                    .catch((error) => this.emit("error", error));
                return;
            }
            this._processingClient
                .sendRpcResponse({
                instanceId: this._instanceId,
                rpcResponse: { jobId, requestId, method, result },
            })
                .catch((error) => this.emit("error", error));
        });
        this._handleJobTimedOut = (jobId, jobKey) => {
            this._activeConversationsByJobId.delete(jobId);
            this.emit("_jobTimedOut", jobId, jobKey);
        };
        this._handleJobRejected = (jobId, jobKey, jobData) => {
            this._activeConversationsByJobId.delete(jobId);
            this.emit("_jobRejected", jobId, jobKey, jobData);
        };
        this._handleJobStarting = (jobId, jobKey, jobData) => {
            this.emit("_jobStarting", jobId, jobKey, jobData);
        };
        this._activeConversationsByJobId = new Map();
        this._handleJobFailed = (jobId, jobKey, jobData) => {
            this._activeConversationsByJobId.delete(jobId);
            this.emit("_jobFailed", jobId, jobKey, jobData);
        };
        this._handleJobCompleted = (jobId, jobKey, jobData) => {
            this._activeConversationsByJobId.delete(jobId);
            this.emit("_jobCompleted", jobId, jobKey, jobData);
        };
        this._handleJobRecordIdReady = (jobId, jobKey, recordId) => {
            this.emit("_jobRecordIdReady", jobId, recordId);
        };
        this._handleJobEvent = (jobId, jobEvent) => {
            this.emit("_jobEvent", jobId, jobEvent);
        };
        //#endregion
        //#region logging
        this._handleDebugLog = (jobId, message) => {
            this.log.info(message, { jobId, label: "application" });
            this.emit("_jobDebugLog", jobId, message);
        };
        //#endregion
        //#region stt provider
        /**
         * An {@link SttDispatcher} callback that selects a speech-to-text engine
         * for all new conversations. If not set explicitly, a `"default"`
         * {@link SttProviderName | STT provider} will be used.
         *
         * @deprecated use {@link Conversation.audio.stt} instead
         */
        this.sttDispatcher = () => "default";
        //#endregion
        //#region tts provider
        /**
         * A {@link TtsDispatcher} callback that selects a text-to-speech engine
         * for all new conversations. If not set explicitly, a `"default"`
         * {@link TtsProviderName | TTS provider} will be used.
         *
         * @deprecated use {@link Conversation.audio.tts} instead
         */
        this.ttsDispatcher = () => "default";
        /**
         * A {@link CustomTtsProvider} callback to use when the {@link TtsProviderName | TTS provider}
         * is set to `"custom"` in {@link Conversation.audio.tts}.
         */
        this.customTtsProvider = () => {
            // imitates an error thrown by a user-supplied connection provider
            // thus, no custom errors or explicit logging here; it all happens at call site
            throw new Error("customTtsProvider was not set");
        };
        this._handleTtsRequest = (request) => __awaiter(this, void 0, void 0, function* () {
            const { requestId, messageId, text, voiceInfo } = request;
            try {
                if (this.customTtsProvider === undefined) {
                    throw new Error("no TTS provider is set");
                }
                let result = yield this.customTtsProvider(text, voiceInfo);
                // have to use duck typing since Fetch API may not be present
                if (!(result instanceof audio.Audio)) {
                    result = yield audio.fromFetchResponse(result);
                }
                yield this._externalTtsClient.sendAudioData({
                    instanceId: this._instanceId,
                    requestId,
                    messageId,
                    audio: {
                        format: result._format,
                        data: result._data,
                    },
                });
            }
            catch (error) {
                try {
                    yield this._externalTtsClient.sendAudioError({
                        instanceId: this._instanceId,
                        requestId,
                        messageId,
                        error: { type: error.name, message: error.message, details: "" },
                    });
                }
                catch (error) {
                    this.emit("error", error);
                }
                if (error instanceof errors.Error) {
                    this.emit("error", error);
                }
                else {
                    this.emit("error", log_1.logAndReturn(this.log, new errors.CustomTtsProviderError(error)));
                }
            }
        });
        //#endregion
        //#region audio client management
        this._handleAudioClientConnect = (audioClientId) => {
            const clientStream = this._processingClient.audioClientStream({ audioClientId });
            this._audioClientStreams.push(clientStream);
            clientStream.on("error", this._handleStreamError);
            clientStream.on("inviteRequest", this._handleAudioClientInviteRequest);
        };
        this._handleAudioClientInviteRequest = (audioClientId, additionalInfo, roomId) => {
            this.emit("_audioClientInviteRequest", audioClientId, additionalInfo, roomId);
        };
        //#endregion
        //#region disposable
        this._isDisposed = false;
        this.log = options.log.child({
            label: `app:${instanceId.slice(-6)}`,
            applicationId,
            instanceId,
            applicationName,
        });
        this.log.info(`applicationId: ${applicationId}`);
        this.log.info(`applicationName: ${applicationName}`);
        this.log.info(`instanceId: ${instanceId}`);
        this._applicationZip = options.applicationZip;
        this.account = options.account;
        this._healthcheckInterval = options.healthcheckInterval;
        this._reconnectInterval = options.reconnectInterval;
        this._maxReconnectCount = options.maxReconnectCount;
        this.applicationId = applicationId;
        this.applicationName = applicationName;
        this._instanceId = instanceId;
        this.customerId = options.customerId;
        this.groupId = options.groupId;
        this._processingClient = processingClient;
        this._instanceStream = instanceStream;
        this.inputSchema = inputSchema;
        this.outputSchema = outputSchema;
        this._runtimeStream = processingClient.runtimeStream({ instanceId });
        this._debugStream = processingClient.debugStream({ instanceId });
        this._audioServerStream = processingClient.audioServerStream({ instanceId });
        this._externalTtsClient = new grpc.externalTtsProtocol.ExternalTtsClient(options.account, this.log);
        this._audioRequestStream = this._externalTtsClient.audioRequestStream({ instanceId });
        this._instanceStream.on("error", this._handleStreamError);
        this._runtimeStream.on("error", this._handleStreamError);
        this._debugStream.on("error", this._handleStreamError);
        this._audioServerStream.on("error", this._handleStreamError);
        this._audioRequestStream.on("error", this._handleStreamError);
        this._instanceStream.on("jobTimedOut", this._handleJobTimedOut);
        this._instanceStream.on("jobRejected", this._handleJobRejected);
        this._instanceStream.on("jobStarting", this._handleJobStarting);
        this._instanceStream.on("jobFailed", this._handleJobFailed);
        this._instanceStream.on("jobCompleted", this._handleJobCompleted);
        this._instanceStream.on("jobRecordIdReady", this._handleJobRecordIdReady);
        this._runtimeStream.on("rpcRequest", this._handleRpcRequest);
        this._debugStream.on("jobEvent", this._handleJobEvent);
        this._debugStream.on("debugLog", this._handleDebugLog);
        this._audioServerStream.on("connect", this._handleAudioClientConnect);
        this._audioRequestStream.on("request", this._handleTtsRequest);
        this.queue = new queue_1.ConversationQueue(this, this.log);
        this.queue.on("error", (error) => this.emit("error", error));
        this.incoming = new incoming_1.IncomingRequestManager(this, this.log);
        this.incoming.on("error", (error) => this.emit("error", error));
        this._healthcheckIntervalHandle = setInterval(this._healthcheck, this._healthcheckInterval);
    }
    /** @internal */
    static _deploy(options) {
        const processingClient = new grpc.processing.ProcessingClient(options.account, options.log);
        const instanceStream = processingClient.registerInstanceStream(Object.assign(Object.assign({}, options), { concurrency: 0, sdkVersion: sdkVersion }));
        return new Promise((resolve, reject) => {
            var _a;
            (_a = options.cancelToken) === null || _a === void 0 ? void 0 : _a._onCancel(options.log, (error) => {
                instanceStream.cancel();
                reject(error);
            });
            instanceStream.on("progress", ({ scopes, description, percent }) => {
                options.log.info(`${scopes.join(": ")}: ${description} ${percent}%`);
            });
            if (options.onProgress !== undefined) {
                instanceStream.on("progress", options.onProgress);
            }
            instanceStream.on("error", (error) => {
                instanceStream.cancel();
                processingClient.close();
                reject(error);
            });
            instanceStream.on("success", (applicationId, instanceId, applicationName, inputSchema, outputSchema) => {
                options.log.info("application deployed");
                instanceStream.removeAllListeners();
                resolve(new Application(options, applicationId, applicationName, instanceId, processingClient, instanceStream, inputSchema, outputSchema));
            });
        });
    }
    /**
     * Start the deployed application, enabling it to receive incoming requests
     * and run queued conversations.
     *
     * @param options.concurrency max number of conversations to run at once
     */
    start(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this._state === ApplicationState.Running) {
                log_1.logAndThrow(this.log, new errors.Error("application is already running"));
            }
            this._state = ApplicationState.Running;
            this._concurrency = (_a = options === null || options === void 0 ? void 0 : options.concurrency) !== null && _a !== void 0 ? _a : 1;
            yield this._processingClient.setInstanceConcurrency({
                instanceId: this._instanceId,
                concurrency: this._concurrency,
            });
            this.log.info(`application started with concurrency ${this._concurrency}`);
        });
    }
    /**
     * Stop the running application, disabling the creation of new conversations.
     * Conversations that are already running are unaffected.
     */
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._state !== ApplicationState.Running) {
                log_1.logAndThrow(this.log, new errors.Error("application is not running"));
            }
            this._state = ApplicationState.Stopped;
            this._concurrency = 0;
            yield this._processingClient.setInstanceConcurrency({
                instanceId: this._instanceId,
                concurrency: this._concurrency,
            });
            this.log.info("application stopped");
        });
    }
    _reconnect(error) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let reconnectCount = 0; reconnectCount < this._maxReconnectCount; reconnectCount += 1) {
                if (!error || (error instanceof errors.ConnectionError && error.reconnectable)) {
                    try {
                        yield this._attemptReconnection(reconnectCount);
                        return;
                    }
                    catch (reconnectError) {
                        error = reconnectError;
                    }
                }
                else {
                    this.emit("error", error);
                    return;
                }
            }
            this.log.info("reconnection limit reached");
        });
    }
    _attemptReconnection(reconnectCount) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: is this okay?
            for (const conv of this._activeConversationsByJobId.values()) {
                this.emit("_jobFailed", conv._jobId, conv._jobKey, { msg: "connection error" });
            }
            this._activeConversationsByJobId.clear();
            this._audioServerStream.cancel();
            for (const stream of this._audioClientStreams)
                stream.cancel();
            this._audioClientStreams = [];
            this._debugStream.cancel();
            this._runtimeStream.cancel();
            this._instanceStream.cancel();
            this._audioRequestStream.cancel();
            if (this._healthcheckIntervalHandle) {
                clearInterval(this._healthcheckIntervalHandle);
                this._healthcheckIntervalHandle = undefined;
            }
            const interval = typeof this._reconnectInterval === "number"
                ? this._reconnectInterval
                : this._reconnectInterval(reconnectCount);
            this.log.info(`reconnecting in ${interval} ms`);
            yield new Promise((cb) => setTimeout(cb, interval));
            this.log.info("reconnecting");
            this._instanceStream = this._processingClient.registerInstanceStream({
                applicationZip: this._applicationZip,
                concurrency: this._concurrency,
                instanceId: this._instanceId,
                groupId: this.groupId,
                sdkVersion: sdkVersion,
            });
            yield new Promise((resolve, reject) => {
                this._instanceStream.on("error", (error) => {
                    this._instanceStream.removeAllListeners();
                    reject(error);
                });
                this._instanceStream.on("success", (applicationId, instanceId) => {
                    this._instanceStream.removeAllListeners();
                    this.applicationId = applicationId;
                    this._instanceId = instanceId;
                    resolve();
                });
            });
            this._runtimeStream = this._processingClient.runtimeStream({ instanceId: this._instanceId });
            this._debugStream = this._processingClient.debugStream({ instanceId: this._instanceId });
            this._audioServerStream = this._processingClient.audioServerStream({
                instanceId: this._instanceId,
            });
            this._audioRequestStream = this._externalTtsClient.audioRequestStream({
                instanceId: this._instanceId,
            });
            this._instanceStream.on("error", this._handleStreamError);
            this._runtimeStream.on("error", this._handleStreamError);
            this._debugStream.on("error", this._handleStreamError);
            this._audioRequestStream.on("error", this._handleStreamError);
            this._instanceStream.on("jobTimedOut", this._handleJobTimedOut);
            this._instanceStream.on("jobRejected", this._handleJobRejected);
            this._instanceStream.on("jobStarting", this._handleJobStarting);
            this._instanceStream.on("jobFailed", this._handleJobFailed);
            this._instanceStream.on("jobCompleted", this._handleJobCompleted);
            this._instanceStream.on("jobRecordIdReady", this._handleJobRecordIdReady);
            this._runtimeStream.on("rpcRequest", this._handleRpcRequest);
            this._debugStream.on("jobEvent", this._handleJobEvent);
            this._debugStream.on("debugLog", this._handleDebugLog);
            this._audioServerStream.on("connect", this._handleAudioClientConnect);
            this._audioRequestStream.on("request", this._handleTtsRequest);
            this._healthcheckIntervalHandle = setInterval(this._healthcheck, this._healthcheckInterval);
            this.log.info(`reconnected with instanceId ${this._instanceId}`);
        });
    }
    /** @internal */
    _executeConnectionProvider(conv) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.connectionProvider === undefined)
                    throw new Error("connectionProvider was not set");
                const connection = yield this.connectionProvider(conv);
                if (connection === undefined)
                    throw new Error("connection provider returned no connection");
                return connection;
            }
            catch (error) {
                log_1.logAndThrow(this.log, new errors.ConnectionProviderError(error));
            }
        });
    }
    /** @internal */
    _addSessionConfig(config) {
        return __awaiter(this, void 0, void 0, function* () {
            let configJson;
            try {
                configJson = JSON.stringify(config);
            }
            catch (error) {
                this.log.debug(error);
                log_1.logAndThrow(this.log, new errors.InternalError("session config is not serializable to JSON", error));
            }
            if (configJson === undefined) {
                log_1.logAndThrow(this.log, new errors.InternalError("session config is not serializable to JSON"));
            }
            const configZip = yield zip.file("config.json", configJson, this.log);
            return yield this._processingClient.addSessionConfig({
                instanceId: this._instanceId,
                configZip,
            });
        });
    }
    /** @internal */
    _configureSession(conversation, executionOptions) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const config = {};
            if (executionOptions.channel === "audio") {
                config.type = "audio";
                config.channel = {
                    type: "sip",
                    configName: (_b = (_a = conversation.sip) === null || _a === void 0 ? void 0 : _a.config) !== null && _b !== void 0 ? _b : "default",
                };
                config.stt = stt._makeSttSessionConfig(conversation.audio.stt, this.log);
                config.tts = tts._makeTtsSessionConfig(conversation.audio.tts, this.log);
                config.vad = {
                    delayAtStartup: conversation.audio.vadStartupDelay,
                    interlocutorPauseDelay: conversation.audio.vadPauseDelay,
                };
                config.noiseVolume = conversation.audio.noiseVolume;
            }
            else if (executionOptions.channel === "text") {
                config.type = "text";
            }
            config.saveLog = true;
            return yield this._processingClient.addSessionConfig({
                instanceId: this._instanceId,
                configZip: yield zip.file("config.json", JSON.stringify(config), this.log),
            });
        });
    }
    /**
     * Set an [external call] handler for this application.
     *
     * The handler is called with all the call arguments passed as a dictionary,
     * as well as the current {@link Conversation} object. It can return a JSON-serializable
     * value, possibly wrapped in a promise, which then is treated as the call's return value.
     * As a special case, `undefined` gets converted to `null`.
     *
     * [external call]: https://docs.dasha.ai/en-us/default/dasha-script-language/external-functions
     */
    setExternal(name, fn) {
        this._externals.set(name, fn);
    }
    //#endregion
    //#region job lifecycle
    /** @internal */
    _enqueueJob(jobKey, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this._processingClient.enqueueJob({
                instanceId: this._instanceId,
                jobs: [
                    {
                        jobId: jobKey,
                        priority: options.priority,
                        after: options.after,
                        before: options.before,
                    },
                ],
            });
            return { jobId: result[0].assignedJobId };
        });
    }
    /** @internal */
    _acceptJob(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._processingClient.acceptJob(Object.assign({ instanceId: this._instanceId, jobId }, options));
        });
    }
    /** @internal */
    _rejectJob(jobId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._processingClient.rejectJob({ instanceId: this._instanceId, jobId });
        });
    }
    /** @internal */
    _bindConversation(jobId, conv) {
        this._activeConversationsByJobId.set(jobId, conv);
    }
    //#endregion
    //#region conversations
    /**
     * Create a single {@link Conversation}.
     *
     * @param input conversation's input data;
     *   can also be set later with {@link Conversation.input}
     */
    createConversation(input) {
        if (this._state !== ApplicationState.Running) {
            log_1.logAndThrow(this.log, new errors.Error("application is not running"));
        }
        return new conversation_1.SingleConversation(this, input, this.log);
    }
    /** @internal */
    _executeSttDispatcher(conv) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const providerName = yield this.sttDispatcher(conv);
                if (providerName === undefined)
                    throw new Error("stt dispather returned no provider name");
                return stt._makeSttSessionConfig(providerName, this.log);
            }
            catch (error) {
                log_1.logAndThrow(this.log, new errors.SttDispatcherError(error));
            }
        });
    }
    /** @internal */
    _executeTtsDispatcher(conv) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const providerName = yield this.ttsDispatcher(conv);
                if (providerName === undefined)
                    throw new Error("tts dispatcher returned no provider name");
                return tts._makeTtsSessionConfig(providerName, this.log);
            }
            catch (error) {
                log_1.logAndThrow(this.log, new errors.TtsDispatcherError(error));
            }
        });
    }
    /** @internal */
    _getAudioClientEndpoint(audioClientId, roomId) {
        return JSON.stringify({
            roomId,
            type: "grpc",
            customerId: this.customerId,
            applicationName: this.applicationName,
            groupId: this.groupId,
            otherAudioClientIds: [audioClientId],
        });
    }
    // TODO: audio client docs
    /**
     * Get the audio client credentials for use with this application.
     */
    getAudioClientAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            const api = new rest.MiscApi(this.account, this.log);
            const token = yield api.getAudioClientAuthToken({
                customerId: this.customerId,
                applicationName: this.applicationName,
                groupId: this.groupId,
            });
            return Object.assign(Object.assign({}, this.account), { apiKey: token });
        });
    }
    //#endregion
    //#region call recordings
    /** @internal */
    _getRecordingUrl(callId) {
        return `${account_1.getBaseHttpUrl(this.account)}/api/v1/records/${callId}`;
    }
    /**
     * Close the connection with the application, freeing all local resources.
     */
    dispose() {
        if (this._isDisposed)
            return;
        this._isDisposed = true;
        this.queue._dispose();
        this.incoming._dispose();
        this._audioRequestStream.cancel();
        this._externalTtsClient.close();
        this._audioServerStream.cancel();
        for (const stream of this._audioClientStreams)
            stream.cancel();
        this._debugStream.cancel();
        this._runtimeStream.cancel();
        this._instanceStream.cancel();
        this._processingClient.close();
        if (this._healthcheckIntervalHandle) {
            clearInterval(this._healthcheckIntervalHandle);
            this._healthcheckIntervalHandle = undefined;
        }
        this.removeAllListeners();
        this.log.info("application disposed of");
    }
}
exports.Application = Application;
//# sourceMappingURL=application.js.map