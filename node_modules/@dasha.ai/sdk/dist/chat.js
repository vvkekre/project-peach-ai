"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleChat = exports.createConsoleChat = exports.Chat = exports.createChat = exports.connect = exports.ChatConnection = void 0;
const readline = __importStar(require("readline"));
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const grpc = __importStar(require("./grpc-api"));
const account_1 = require("./account");
const log_1 = require("./log");
/** @internal */
class ChatConnection {
    /** @internal */
    constructor(chat) {
        /** @internal */ this._sessionConfig = { type: "text" };
        this._chat = chat;
    }
    /** @internal */ _init(jobId) {
        this._chat._init(jobId);
    }
}
exports.ChatConnection = ChatConnection;
/**
 * Connect the application to a {@link Chat} instance.
 *
 * @see ConnectionProvider
 *
 * @deprecated use the `channel` parameter to {@link Conversation.execute} instead
 */
function connect(chat) {
    return new ChatConnection(chat);
}
exports.connect = connect;
function createChat(accountOrConversation, options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (accountOrConversation === undefined || "apiKey" in accountOrConversation) {
            const account = accountOrConversation;
            return new Chat(account !== null && account !== void 0 ? account : (yield account_1._getEffectiveAccount({ _log: log_1.log })));
        }
        const conversation = accountOrConversation;
        return new Chat((_a = options === null || options === void 0 ? void 0 : options.account) !== null && _a !== void 0 ? _a : (yield account_1._getEffectiveAccount({ _log: log_1.log })), conversation);
    });
}
exports.createChat = createChat;
/**
 * A text-based means of communication with an {@link Application}.
 */
class Chat extends eventemitter3_1.default {
    /**
     * Create a {@link Chat} instance to use with an application.
     *
     * @param account Dasha account to use. Must be the same as the application's account.
     */
    constructor(account, conversation) {
        super();
        this._handleText = (_jobId, text) => {
            this.emit("text", text);
        };
        this._handleClose = () => {
            this.emit("close");
        };
        this._textProtocolClient = new grpc.textProtocol.TextProtocolClient(account, log_1.log);
        conversation === null || conversation === void 0 ? void 0 : conversation.once("debugLog", () => this._init(conversation._jobId));
    }
    /** @internal */
    _init(jobId) {
        this._jobId = jobId;
        this._messageStream = this._textProtocolClient.messageStream({ jobId });
        this._messageStream.on("error", (error) => this.emit("error", error));
        this._messageStream.on("text", this._handleText);
        this._messageStream.on("close", this._handleClose);
    }
    /**
     * Send some text to the application.
     */
    sendText(text) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._textProtocolClient.sendText({ jobId: this._jobId, text });
        });
    }
    /**
     * Close the chat, notifying the application.
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._textProtocolClient.sendClose({ jobId: this._jobId });
        });
    }
}
exports.Chat = Chat;
function createConsoleChat(accountOrConversation, options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (accountOrConversation === undefined || "apiKey" in accountOrConversation) {
            const account = accountOrConversation;
            return new ConsoleChat(account !== null && account !== void 0 ? account : (yield account_1._getEffectiveAccount({ _log: log_1.log })));
        }
        const conversation = accountOrConversation;
        return new ConsoleChat((_a = options === null || options === void 0 ? void 0 : options.account) !== null && _a !== void 0 ? _a : (yield account_1._getEffectiveAccount({ _log: log_1.log })), conversation);
    });
}
exports.createConsoleChat = createConsoleChat;
/**
 * A simple, console-based {@link Chat} wrapper for testing and debugging applications.
 * Only available in Node.js.
 */
class ConsoleChat extends Chat {
    constructor(account, conversation) {
        super(account, conversation);
        this._interface = readline.createInterface(process.stdin);
        this._interface.on("line", (text) => {
            this.sendText(text).catch((error) => this.emit("error", error));
        });
    }
    /** @internal */
    _init(jobId) {
        super._init(jobId);
        console.log("chat started");
        this.on("text", (text) => console.log(`AI: ${text}`));
        this.on("close", () => this._interface.close());
    }
}
exports.ConsoleChat = ConsoleChat;
//# sourceMappingURL=chat.js.map