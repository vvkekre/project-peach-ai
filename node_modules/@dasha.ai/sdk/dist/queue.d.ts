import EventEmitter from "eventemitter3";
import * as audio from "./audio";
import * as errors from "./errors";
import * as sip from "./sip";
import { CancelToken } from "./cancel";
import { Conversation, ConversationResult } from "./conversation";
import { Logger } from "./log";
import { Transcription } from "./transcription";
/**
 * @see {@link ConversationQueue}
 */
export interface QueuedConversationInfo {
    sip?: {
        fromUser: string;
        fromDomain: string;
        toUser: string;
        toDomain: string;
        diversion: string[];
    };
}
/**
 * Manages planned conversations.
 *
 * A conversation may be _enqueued_, that is, planned to execute in a specific time frame.
 * When the conversation is to be executed, a `"ready"` event is fired on this object,
 * that gets passed a {@link Conversation} object to populate its input and run.
 *
 * The queue is stored on the Dasha platform. To associate an enqueued conversation
 * with its data, each conversation is assigned a _key_.
 *
 * @example running enqueued conversations
 * ```typescript
 * application.queue.on("ready", async (key, conversation) => {
 *   conversation.input = getInput(key);
 *   const result = await conversation.execute();
 * });
 * ```
 *
 * Sometimes, the conversation can be removed from the queue by the Dasha platform itself.
 * In that case, a `"rejected"` event is fired.
 *
 * @example conversation rejection
 * ```typescript
 * application.queue.on("rejected", (key, error) => {
 *   console.log(`conversation with key ${key} was rejected`, error);
 * });
 * ```
 *
 * There is an important caveat with the incoming SIP conversations.
 * They get placed in the queue automatically, by the Dasha platform itself.
 * To discern them from the manually-enqueued conversations, and to get the additional
 * SIP info (e.g. the SIP user and domain of the conversation partner),
 * the `"ready"` event has an extra argument of type {@link QueuedConversationInfo}.
 *
 * @example using SIP data in a conversation
 * ```typescript
 * application.queue.on("ready", (key, conversation, info) => {
 *   assert(info.sip !== undefined);
 *   conversation.input.from = `${info.fromUser}@${info.fromDomain}`;
 *   await conversation.execute();
 * });
 * ```
 */
export declare class ConversationQueue<TInput extends Record<string, unknown>, TOutput extends Record<string, unknown>> extends EventEmitter<{
    error: [error: errors.Error];
    ready: [key: string, conv: QueuedConversation<TInput, TOutput>, info: QueuedConversationInfo];
    timeout: [key: string];
    rejected: [key: string, error: errors.ConversationRejectedError];
}> {
    private _log;
    private _application;
    private _ignoredJobKeys;
    private _activeConversationsByJobKey;
    private _isDisposed;
    /**
     * Push a new conversation into the queue.
     *
     * @param key a conversation key that can be used to associate data
     * @param options.after the earliest point in time the conversation can run at
     * @param options.before the latest point in time the conversation can run at
     * @returns Object with internal backend jobId
     * @example enqueue a conversation to within an hour
     * ```typescript
     * application.queue.push("key", {
     *   after: new Date(),
     *   before: new Date(Date.now() + 60 * 60 * 1000)
     * });
     * ```
     */
    push(key: string, options?: {
        after?: Date;
        before?: Date;
        priority?: number;
    }): Promise<{
        jobId: string;
    }>;
    /**
     * Get current queue length at the server side.
     */
    length(): Promise<number>;
    private _handleJobTimedOut;
    private _handleJobRejected;
    private _handleJobStarting;
    private _handleJobCompleted;
    private _handleJobFailed;
}
export declare class QueuedConversation<TInput extends Record<string, unknown>, TOutput extends Record<string, unknown>> extends EventEmitter<{
    debugLog: [event: unknown];
    transcription: [transcription: Transcription];
}> implements Conversation<TInput, TOutput> {
    readonly log: Logger;
    input: TInput;
    audio: audio.AudioConfig;
    sip: sip.SipConfig;
    private _application;
    private _transcription;
    private _transcriptionParser;
    private _recordingUrl?;
    /**
     *  Explicitly mark this conversation as not being executed, freeing up server-side resources
     */
    ignore(): Promise<void>;
    execute(options?: {
        channel: "audio" | "text";
        cancelToken?: CancelToken;
    }): Promise<ConversationResult<TOutput>>;
}
