"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WritableAudioStream = exports.ReadableAudioStream = exports.AudioChannel = exports.connect = void 0;
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const events_1 = require("events");
const stream_1 = require("stream");
const log_1 = require("./log");
const errors = __importStar(require("./errors"));
const grpc = __importStar(require("./grpc-api"));
function connect(clientAccount, options) {
    return new Promise((resolve, reject) => {
        var _a;
        const additionalInfo = (_a = options === null || options === void 0 ? void 0 : options.additionalInfo) !== null && _a !== void 0 ? _a : "";
        const channel = new AudioChannel(clientAccount, { additionalInfo });
        channel.once("error", reject);
        channel.once("_ready", resolve);
    });
}
exports.connect = connect;
class AudioChannel extends eventemitter3_1.default {
    /** @internal */ constructor(clientAccount, options) {
        super();
        this._handleError = (error) => {
            this.emit("error", error);
            this.disconnect();
        };
        this._handleTerminate = (roomId, reason, details) => {
            if (reason === grpc.audioGatewayProtocol.TerminationReason.DISCONNECTED) {
                const error = new errors.AudioRoomDisconnectedError(roomId, details);
                this.emit("error", error);
            }
            if (reason === grpc.audioGatewayProtocol.TerminationReason.FORBIDDEN) {
                const error = new errors.AudioRoomForbiddenError(roomId, details);
                this.emit("error", error);
            }
            if (reason === grpc.audioGatewayProtocol.TerminationReason.NOT_FOUND) {
                const error = new errors.AudioRoomNotFoundError(roomId, details);
                this.emit("error", error);
            }
            this.disconnect();
        };
        this._handleLeave = (_roomId, audioClientId) => {
            if (audioClientId !== this._audioClientId) {
                this.disconnect();
            }
        };
        this._init(clientAccount, options);
    }
    _init(clientAccount, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const additionalInfo = options.additionalInfo;
            this._log = log_1.log.child({
                clientAccount,
                label: `audio-client:${clientAccount.apiKey.slice(-6)}`,
            });
            this._log.info(`connecting to ${clientAccount.server}`);
            if (clientAccount.insecure)
                this._log.warn(`TLS is disabled`);
            this._gatewayClient = new grpc.audioGatewayProtocol.AudioGatewayProtocolClient(clientAccount, this._log);
            this._audioStreamClient = new grpc.audioStreamProtocol.AudioStreamProtocolClient(clientAccount, this._log);
            this._connectionStream = this._gatewayClient.connect({ additionalInfo });
            this._connectionStream.on("error", this._handleError);
            this._connectionStream.on("terminate", this._handleTerminate);
            this._connectionStream.on("leave", this._handleLeave);
            const [audioClientId] = yield events_1.once(this._connectionStream, "connect");
            this._audioClientId = audioClientId;
            yield this._gatewayClient.inviteRequest({
                roomId: "00000000-0000-0000-0000-000000000000",
                additionalInfo,
            });
            const [roomId] = yield events_1.once(this._connectionStream, "invite");
            this._roomId = roomId;
            this._backendAudioStream = this._audioStreamClient.audioStream();
            this._backendAudioStream.on("error", this._handleError);
            this._backendAudioStream.writeInfo({
                roomId: this._roomId,
                encoding: grpc.audioStreamProtocol.AudioEncoding.LINEAR16,
                sampleRate: 8000,
            });
            this._audioMixer = new AudioMixer({
                backendAudioStream: this._backendAudioStream,
                backendSampleRate: 8000,
                mixBufferDuration: 0.16,
                pushInterval: 20,
            });
            this.emit("_ready", this);
        });
    }
    createReadableStream(options) {
        var _a, _b;
        return new ReadableAudioStream({
            backendAudioStream: this._backendAudioStream,
            backendSampleRate: 8000,
            channelCount: (_a = options === null || options === void 0 ? void 0 : options.channelCount) !== null && _a !== void 0 ? _a : 1,
            sampleRate: (_b = options === null || options === void 0 ? void 0 : options.sampleRate) !== null && _b !== void 0 ? _b : 8000,
        });
    }
    createWritableStream(options) {
        var _a, _b;
        return this._audioMixer.createWritableAudioStream({
            channelCount: (_a = options === null || options === void 0 ? void 0 : options.channelCount) !== null && _a !== void 0 ? _a : 1,
            sampleRate: (_b = options === null || options === void 0 ? void 0 : options.sampleRate) !== null && _b !== void 0 ? _b : 8000,
        });
    }
    disconnect() {
        this._audioStreamClient.close();
        this._gatewayClient.close();
        this.emit("close");
    }
}
exports.AudioChannel = AudioChannel;
class ReadableAudioStream extends stream_1.Readable {
    /** @internal */ constructor(options) {
        super();
        this._isPushing = false;
        this._handleAudio = (_streamId, _time, data) => {
            if (!this._isPushing)
                return;
            const factor = this._channelCount * this._sampleRateRatio;
            const rawChunk = Buffer.from(data);
            const outChunk = Buffer.allocUnsafe(rawChunk.length * factor);
            for (let i = 0; i < rawChunk.length; i += 2) {
                for (let j = 0; j < factor; j += 1) {
                    outChunk[factor * i + 2 * j + 0] = rawChunk[i + 0];
                    outChunk[factor * i + 2 * j + 1] = rawChunk[i + 1];
                }
                this._backendSampleRate;
            }
            this._isPushing = this.push(outChunk);
        };
        this._handleEnd = () => {
            this.destroy();
        };
        this._handleError = (error) => {
            this.destroy(error);
        };
        this._backendAudioStream = options.backendAudioStream;
        this._backendSampleRate = options.backendSampleRate;
        this._channelCount = options.channelCount;
        this._sampleRateRatio = options.sampleRate / options.backendSampleRate;
        this._backendAudioStream.on("audio", this._handleAudio);
        this._backendAudioStream.on("end", this._handleEnd);
        this._backendAudioStream.on("error", this._handleError);
    }
    _read(_size) {
        this._isPushing = true;
    }
}
exports.ReadableAudioStream = ReadableAudioStream;
class AudioMixer {
    constructor(options) {
        this._streams = [];
        this._streamPointers = [];
        this._handleEnd = () => {
            clearInterval(this._pushIntervalHandle);
            for (const stream of this._streams)
                stream.destroy();
        };
        this._handleError = (error) => {
            clearInterval(this._pushIntervalHandle);
            for (const stream of this._streams)
                stream.destroy(error);
        };
        this._backendAudioStream = options.backendAudioStream;
        this._backendSampleRate = options.backendSampleRate;
        this._backendAudioStream.on("end", this._handleEnd);
        this._backendAudioStream.on("error", this._handleError);
        this._mixBuffer = Buffer.alloc(Math.round(2 * options.backendSampleRate * options.mixBufferDuration));
        this._pushByteCount = Math.round((2 * options.backendSampleRate * options.pushInterval) / 1000);
        this._pushIntervalHandle = setInterval(() => this._pushToBackend(), options.pushInterval);
    }
    _pushToBackend() {
        const pushBuffer = Buffer.from(this._mixBuffer.slice(0, this._pushByteCount));
        this._backendAudioStream.writeAudio(pushBuffer);
        this._mixBuffer.copyWithin(0, this._pushByteCount);
        this._mixBuffer.fill(0, this._mixBuffer.length - this._pushByteCount);
        for (let i = 0; i < this._streamPointers.length; i += 1) {
            this._streamPointers[i] -= this._pushByteCount;
            if (this._streamPointers[i] < 0)
                this._streamPointers[i] = 0;
        }
    }
    _streamWrite(streamIndex, data) {
        const streamPointer = this._streamPointers[streamIndex];
        const bytesToWrite = Math.min(data.length, this._mixBuffer.length - streamPointer);
        for (let i = 0; i < bytesToWrite; i += 2) {
            let value = this._mixBuffer.readInt16LE(streamPointer + i) + data.readInt16LE(i);
            if (value < -(1 << 15))
                value = -(1 << 15);
            if (value > (1 << 15) - 1)
                value = (1 << 15) - 1;
            this._mixBuffer.writeInt16LE(value, streamPointer + i);
        }
        this._streamPointers[streamIndex] += bytesToWrite;
    }
    _streamDestroy(streamIndex) {
        if (this._streams.length === 1) {
            this._streams.pop();
            this._streamPointers.pop();
            return;
        }
        this._streams[this._streams.length - 1]._streamIndex = streamIndex;
        this._streams[streamIndex] = this._streams[this._streams.length - 1];
        this._streams.pop();
        this._streamPointers[streamIndex] = this._streamPointers[this._streams.length - 1];
        this._streamPointers.pop();
    }
    createWritableAudioStream(options) {
        const stream = new WritableAudioStream({
            audioMixer: this,
            streamIndex: this._streams.length,
            backendSampleRate: this._backendSampleRate,
            channelCount: options.channelCount,
            sampleRate: options.sampleRate,
        });
        this._streams.push(stream);
        this._streamPointers.push(0);
        return stream;
    }
}
class WritableAudioStream extends stream_1.Writable {
    /** @internal */ constructor(options) {
        super();
        this._audioMixer = options.audioMixer;
        this._streamIndex = options.streamIndex;
        this._channelCount = options.channelCount;
        this._sampleRateRatio = options.sampleRate / options.backendSampleRate;
    }
    _write(chunk, _encoding, cb) {
        const factor = this._channelCount * this._sampleRateRatio;
        const outChunk = Buffer.allocUnsafe(chunk.length / factor);
        for (let i = 0; i < outChunk.length; i += 2) {
            outChunk[i + 0] = chunk[factor * i + 0];
            outChunk[i + 1] = chunk[factor * i + 1];
        }
        this._audioMixer._streamWrite(this._streamIndex, outChunk);
        cb();
    }
    _destroy(_error) {
        this._audioMixer._streamDestroy(this._streamIndex);
    }
}
exports.WritableAudioStream = WritableAudioStream;
//# sourceMappingURL=audio-client.js.map