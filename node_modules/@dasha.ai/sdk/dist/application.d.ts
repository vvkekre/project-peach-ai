import EventEmitter from "eventemitter3";
import * as errors from "./errors";
import * as stt from "./stt";
import * as tts from "./tts";
import { Account } from "./account";
import { ConnectionProvider } from "./connection";
import { Conversation } from "./conversation";
import { IncomingRequestManager } from "./incoming";
import { Logger } from "./log";
import { ConversationQueue } from "./queue";
/**
 * A [DashaScript](https://docs.dasha.ai/en-us/default/dasha-script-language/)
 * conversational application {@link deploy | deployed} to the Dasha platform.
 *
 * @template TInput conversation input data type
 * @template TOutput conversation output data type
 */
export declare class Application<TInput extends Record<string, unknown>, TOutput extends Record<string, unknown>> extends EventEmitter<{
    error: [error: errors.Error];
}> {
    readonly log: Logger;
    private readonly _applicationZip;
    /**
     * A user {@link Account} that the application was deployed under.
     */
    readonly account: Account;
    /**
     * An internal application UID.
     */
    applicationId: string;
    /**
     * Application name as seen in [`.dashaapp`].
     * [`.dashaapp`]: https://docs.dasha.ai/en-us/default/application/configuration/#application-name
     */
    applicationName: string;
    /**
     * JSON Schema of DSL context input variables.
     * Conversation context: https://docs.dasha.ai/en-us/default/dasha-script-language/conversation-context
     */
    inputSchema?: unknown;
    /**
     * JSON Schema of DSL context output variables.
     * Conversation context: https://docs.dasha.ai/en-us/default/dasha-script-language/conversation-context
     */
    outputSchema?: unknown;
    private _instanceId;
    /**
     * An internal client UID.
     */
    readonly customerId: string;
    /**
     * An internal application group UID.
     */
    readonly groupId: string;
    private readonly _processingClient;
    private _instanceStream;
    private _runtimeStream;
    private _debugStream;
    private _audioServerStream;
    private _audioClientStreams;
    private readonly _externalTtsClient;
    private _audioRequestStream;
    private readonly _healthcheckInterval;
    private _healthcheckIntervalHandle?;
    private readonly _reconnectInterval;
    private readonly _maxReconnectCount;
    private _state;
    private _concurrency;
    private constructor();
    /**
     * Start the deployed application, enabling it to receive incoming requests
     * and run queued conversations.
     *
     * @param options.concurrency max number of conversations to run at once
     */
    start(options?: {
        concurrency?: number;
    }): Promise<void>;
    /**
     * Stop the running application, disabling the creation of new conversations.
     * Conversations that are already running are unaffected.
     */
    stop(): Promise<void>;
    private _healthcheck;
    private _handleStreamError;
    private _reconnect;
    private _attemptReconnection;
    /**
     * A {@link ConnectionProvider} to use for this application's conversations.
     *
     * @deprecated use the `channel` argument to {@link Conversation.execute} instead
     */
    connectionProvider?: ConnectionProvider<TInput, TOutput>;
    private _externals;
    /**
     * Set an [external call] handler for this application.
     *
     * The handler is called with all the call arguments passed as a dictionary,
     * as well as the current {@link Conversation} object. It can return a JSON-serializable
     * value, possibly wrapped in a promise, which then is treated as the call's return value.
     * As a special case, `undefined` gets converted to `null`.
     *
     * [external call]: https://docs.dasha.ai/en-us/default/dasha-script-language/external-functions
     */
    setExternal<TArgs extends Record<string, unknown>>(name: string, fn: (args: TArgs, conv: Conversation<TInput, TOutput>) => unknown): void;
    private _handleRpcRequest;
    private _handleJobTimedOut;
    private _handleJobRejected;
    private _handleJobStarting;
    private _activeConversationsByJobId;
    private _handleJobFailed;
    private _handleJobCompleted;
    private _handleJobRecordIdReady;
    private _handleJobEvent;
    private _handleDebugLog;
    /**
     * Create a single {@link Conversation}.
     *
     * @param input conversation's input data;
     *   can also be set later with {@link Conversation.input}
     */
    createConversation(input?: TInput): Conversation<TInput, TOutput>;
    /**
     * A {@link ConversationQueue} object for managing planned conversations.
     */
    readonly queue: ConversationQueue<TInput, TOutput>;
    /**
     * An {@link SttDispatcher} callback that selects a speech-to-text engine
     * for all new conversations. If not set explicitly, a `"default"`
     * {@link SttProviderName | STT provider} will be used.
     *
     * @deprecated use {@link Conversation.audio.stt} instead
     */
    sttDispatcher: stt.SttDispatcher<TInput, TOutput>;
    /**
     * A {@link TtsDispatcher} callback that selects a text-to-speech engine
     * for all new conversations. If not set explicitly, a `"default"`
     * {@link TtsProviderName | TTS provider} will be used.
     *
     * @deprecated use {@link Conversation.audio.tts} instead
     */
    ttsDispatcher: tts.TtsDispatcher<TInput, TOutput>;
    /**
     * A {@link CustomTtsProvider} callback to use when the {@link TtsProviderName | TTS provider}
     * is set to `"custom"` in {@link Conversation.audio.tts}.
     */
    customTtsProvider: tts.CustomTtsProvider;
    private _handleTtsRequest;
    private _handleAudioClientConnect;
    private _handleAudioClientInviteRequest;
    /**
     * Get the audio client credentials for use with this application.
     */
    getAudioClientAccount(): Promise<Account>;
    /**
     * An {@link IncomingRequestManager} instance for accepting incoming conversation requests,
     * e.g. when using voice-over-gRPC.
     */
    readonly incoming: IncomingRequestManager<TInput, TOutput>;
    private _isDisposed;
    /**
     * Close the connection with the application, freeing all local resources.
     */
    dispose(): void;
}
