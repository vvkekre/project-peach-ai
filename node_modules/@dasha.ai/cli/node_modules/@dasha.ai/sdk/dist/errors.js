"use strict";
/**
 * All errors thrown by the Dasha SDK are subclasses of the base {@link Error} class.
 *
 * @module
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TtsDispatcherError = exports.TimeoutError = exports.SttDispatcherError = exports.SipConfigNotFoundError = exports.SipConfigExistsError = exports.OptionalDependencyNotFoundError = exports.NotImplementedError = exports.InternalError = exports.GroupNotFoundError = exports.GroupExistsError = exports.FileSystemError = exports.ExternalResultNotSerializableError = exports.ExternalNotFoundError = exports.DeploymentError = exports.CustomTtsProviderError = exports.ConversationRejectedError = exports.ConversationError = exports.ConnectionProviderError = exports.ConnectionError = exports.CancelError = exports.AuthenticationError = exports.AudioError = exports.ArgumentError = exports.AccountNotFoundError = exports.AccountExistsError = exports.Error = void 0;
class Error extends globalThis.Error {
    constructor(message, reason) {
        super(message);
        this.reason = reason;
        this.name = "dasha.Error";
    }
}
exports.Error = Error;
class AccountExistsError extends Error {
    constructor(accountName) {
        super(`account already exists: ${accountName}`);
        this.accountName = accountName;
        this.name = "dasha.AccountExists";
    }
}
exports.AccountExistsError = AccountExistsError;
class AccountNotFoundError extends Error {
    constructor(accountName) {
        super(`account not found: ${accountName}`);
        this.accountName = accountName;
        this.name = "dasha.AccountNotFoundError";
    }
}
exports.AccountNotFoundError = AccountNotFoundError;
class ArgumentError extends Error {
    constructor(message) {
        super(message);
        this.name = "dasha.ArgumentError";
    }
}
exports.ArgumentError = ArgumentError;
class AudioError extends Error {
    constructor(message) {
        super(message);
        this.name = "dasha.AudioError";
    }
}
exports.AudioError = AudioError;
class AuthenticationError extends Error {
    constructor() {
        super("authentication error; check your API key");
        this.name = "dasha.AuthenticationError";
    }
}
exports.AuthenticationError = AuthenticationError;
class CancelError extends Error {
    constructor() {
        super("operation was canceled");
        this.name = "dasha.CancelError";
    }
}
exports.CancelError = CancelError;
class ConnectionError extends Error {
    constructor(internalMessage, reason, reconnectable = false) {
        super("connection error; check your account settings and network connection");
        this.internalMessage = internalMessage;
        this.reason = reason;
        this.reconnectable = reconnectable;
        this.name = "dasha.ConnectionError";
    }
}
exports.ConnectionError = ConnectionError;
class ConnectionProviderError extends Error {
    constructor(reason) {
        super(`connection provider error: ${reason.message}`);
        this.reason = reason;
        this.name = "dasha.ConnectionProviderError";
    }
}
exports.ConnectionProviderError = ConnectionProviderError;
class ConversationError extends Error {
    constructor(data) {
        super(`conversation failed: ${data.msg}`);
        this.data = data;
        this.name = "dasha.ConversationError";
    }
}
exports.ConversationError = ConversationError;
class ConversationRejectedError extends Error {
    constructor(data) {
        super(`conversation rejected: ${data.reason}`);
        this.data = data;
        this.name = "dasha.ConversationRejectedError";
    }
}
exports.ConversationRejectedError = ConversationRejectedError;
class CustomTtsProviderError extends Error {
    constructor(reason) {
        super(`custom TTS provider error: ${reason.message}`);
        this.reason = reason;
        this.name = "dasha.CustomTtsProviderError";
    }
}
exports.CustomTtsProviderError = CustomTtsProviderError;
class DeploymentError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        this.name = "dasha.DeploymentError";
    }
}
exports.DeploymentError = DeploymentError;
class ExternalNotFoundError extends Error {
    constructor(method) {
        super(`external function not found: ${method}`);
        this.method = method;
        this.name = "dasha.ExternalNotFoundError";
    }
}
exports.ExternalNotFoundError = ExternalNotFoundError;
class ExternalResultNotSerializableError extends Error {
    constructor(method) {
        super(`external function ${method} return value not serializable to JSON`);
        this.method = method;
        this.name = "dasha.ExternalResultNotSerializableError";
    }
}
exports.ExternalResultNotSerializableError = ExternalResultNotSerializableError;
class FileSystemError extends Error {
    constructor(reason) {
        super(`file system error: ${reason.message}`);
        this.reason = reason;
        this.name = "dasha.FileSystemError";
    }
}
exports.FileSystemError = FileSystemError;
class GroupExistsError extends Error {
    constructor(groupName) {
        super(`group exists: ${groupName}`);
        this.groupName = groupName;
        this.name = "dasha.GroupExistsError";
    }
}
exports.GroupExistsError = GroupExistsError;
class GroupNotFoundError extends Error {
    constructor(groupName) {
        super(`group not found: ${groupName}`);
        this.groupName = groupName;
        this.name = "dasha.GroupNotFoundError";
    }
}
exports.GroupNotFoundError = GroupNotFoundError;
class InternalError extends Error {
    constructor(internalMessage, reason) {
        super("internal error");
        this.internalMessage = internalMessage;
        this.reason = reason;
        this.name = "dasha.InternalError";
    }
}
exports.InternalError = InternalError;
class NotImplementedError extends Error {
    constructor(message) {
        super(message !== null && message !== void 0 ? message : "not implemented");
        this.name = "dasha.NotImplementedError";
    }
}
exports.NotImplementedError = NotImplementedError;
class OptionalDependencyNotFoundError extends Error {
    constructor(importPath) {
        super(`optional dependency not found: ${importPath}`);
        this.importPath = importPath;
        this.name = "dasha.OptionalDependencyNotFoundError";
    }
}
exports.OptionalDependencyNotFoundError = OptionalDependencyNotFoundError;
class SipConfigExistsError extends Error {
    constructor(configName) {
        super(`SIP config already exists: ${configName}`);
        this.configName = configName;
        this.name = "dasha.SipConfigExistsError";
    }
}
exports.SipConfigExistsError = SipConfigExistsError;
class SipConfigNotFoundError extends Error {
    constructor(configName) {
        super(`SIP config not found: ${configName}`);
        this.configName = configName;
        this.name = "dasha.SipConfigNotFoundError";
    }
}
exports.SipConfigNotFoundError = SipConfigNotFoundError;
class SttDispatcherError extends Error {
    constructor(reason) {
        super(`STT dispatcher error: ${reason.message}`);
        this.reason = reason;
        this.name = "dasha.SttDispatcherError";
    }
}
exports.SttDispatcherError = SttDispatcherError;
class TimeoutError extends Error {
    constructor(message) {
        super(message !== null && message !== void 0 ? message : "timed out");
        this.name = "dasha.TimeoutError";
    }
}
exports.TimeoutError = TimeoutError;
class TtsDispatcherError extends Error {
    constructor(reason) {
        super(`TTS dispatcher error: ${reason.message}`);
        this.reason = reason;
        this.name = "dasha.TtsDispatcherError";
    }
}
exports.TtsDispatcherError = TtsDispatcherError;
//# sourceMappingURL=errors.js.map