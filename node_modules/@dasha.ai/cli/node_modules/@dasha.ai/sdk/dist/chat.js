"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleChat = exports.createConsoleChat = exports.Chat = exports.createChat = exports.connect = exports.ChatConnection = void 0;
const readline = require("readline");
const EventEmitter = require("eventemitter3");
const grpc = require("./grpc-api");
const account_1 = require("./account");
const log_1 = require("./log");
/** @internal */
class ChatConnection {
    /** @internal */
    constructor(chat) {
        /** @internal */ this._sessionConfig = { type: "text" };
        this._chat = chat;
    }
    /** @internal */ _init(jobId) {
        this._chat._init(jobId);
    }
}
exports.ChatConnection = ChatConnection;
/**
 * Connect the application to a {@link Chat} instance.
 *
 * @see ConnectionProvider
 */
function connect(chat) {
    return new ChatConnection(chat);
}
exports.connect = connect;
/**
 * Create a {@link Chat} instance to use with an application.
 *
 * @param account Dasha account to use. Must be the same as the application's account.
 *   If not set, uses the {@link getCurrentAccountName | current account}.
 */
function createChat(account) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Chat(account !== null && account !== void 0 ? account : (yield account_1._getEffectiveAccount({ _log: log_1.log })));
    });
}
exports.createChat = createChat;
/**
 * A text-based means of communication with an {@link Application}.
 */
class Chat extends EventEmitter {
    /**
     * Create a {@link Chat} instance to use with an application.
     *
     * @param account Dasha account to use. Must be the same as the application's account.
     */
    constructor(account) {
        super();
        this._handleText = (_jobId, text) => {
            this.emit("text", text);
        };
        this._handleClose = () => {
            this.emit("close");
        };
        this._textProtocolClient = new grpc.textProtocol.TextProtocolClient(account, log_1.log);
    }
    /** @internal */
    _init(jobId) {
        this._jobId = jobId;
        this._messageStream = this._textProtocolClient.messageStream({ jobId });
        this._messageStream.on("error", (error) => this.emit("error", error));
        this._messageStream.on("text", this._handleText);
        this._messageStream.on("close", this._handleClose);
    }
    /**
     * Send some text to the application.
     */
    sendText(text) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._textProtocolClient.sendText({ jobId: this._jobId, text });
        });
    }
    /**
     * Close the chat, notifying the application.
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._textProtocolClient.sendClose({ jobId: this._jobId });
        });
    }
}
exports.Chat = Chat;
/**
 * Create a {@link ConsoleChat} instance to use with an application.
 *
 * @param account Dasha account to use. Must be the same as the application's account.
 *   If not set, uses the {@link getCurrentAccountName | current account}.
 */
function createConsoleChat(account) {
    return __awaiter(this, void 0, void 0, function* () {
        return new ConsoleChat(account !== null && account !== void 0 ? account : (yield account_1._getEffectiveAccount({ _log: log_1.log })));
    });
}
exports.createConsoleChat = createConsoleChat;
/**
 * A simple, console-based {@link Chat} wrapper for testing and debugging applications.
 * Only available in Node.js.
 */
class ConsoleChat extends Chat {
    constructor(account) {
        super(account);
        this._interface = readline.createInterface(process.stdin);
        this._interface.on("line", (text) => {
            this.sendText(text).catch((error) => this.emit("error", error));
        });
    }
    /** @internal */
    _init(jobId) {
        super._init(jobId);
        console.log("chat started");
        this.on("text", (text) => console.log(`AI: ${text}`));
        this.on("close", () => this._interface.close());
    }
}
exports.ConsoleChat = ConsoleChat;
//# sourceMappingURL=chat.js.map