"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Application = void 0;
const EventEmitter = require("eventemitter3");
const audio = require("./audio");
const errors = require("./errors");
const grpc = require("./grpc-api");
const rest = require("./rest-api");
const stt = require("./stt");
const tts = require("./tts");
const zip = require("./zip");
const account_1 = require("./account");
const conversation_1 = require("./conversation");
const incoming_1 = require("./incoming");
const log_1 = require("./log");
const queue_1 = require("./queue");
var ApplicationState;
(function (ApplicationState) {
    ApplicationState[ApplicationState["Initial"] = 0] = "Initial";
    ApplicationState[ApplicationState["Stopped"] = 1] = "Stopped";
    ApplicationState[ApplicationState["Running"] = 2] = "Running";
})(ApplicationState || (ApplicationState = {}));
// reference-style links don't seem to work here, for whatever reason
/**
 * A [DashaScript](https://docs.dasha.ai/en-us/default/dasha-script-language/)
 * conversational application {@link deploy | deployed} to the Dasha platform.
 *
 * @template TInput conversation input data type
 * @template TOutput conversation output data type
 */
class Application extends EventEmitter {
    constructor(options, applicationId, applicationName, instanceId, processingClient, instanceStream) {
        super();
        this._audioClientStreams = [];
        //#region lifecycle
        this._state = ApplicationState.Initial;
        this._concurrency = 0;
        //#endregion
        //#region stream reconnects
        this._handleStreamError = (error) => __awaiter(this, void 0, void 0, function* () {
            for (let reconnectCount = 0; reconnectCount < this._maxReconnectCount; reconnectCount += 1) {
                if (error instanceof errors.ConnectionError && error.reconnectable) {
                    try {
                        yield this._reconnect();
                        return;
                    }
                    catch (reconnectError) {
                        error = reconnectError;
                    }
                }
                else {
                    this.emit("error", error);
                    return;
                }
            }
            this.log.info("reconnection limit reached");
            this.emit("error", error);
        });
        //#endregion
        //#region connections
        /**
         * A {@link ConnectionProvider} to use for this application's conversations.
         * _Must_ be set before starting any conversations.
         */
        this.connectionProvider = () => {
            // imitates an error thrown by a user-supplied connection provider
            // thus, no custom errors or explicit logging here; it all happens at call site
            throw new Error("connectionProvider was not set");
        };
        //#endregion
        //#region external call handlers
        // cannot type better because of variance problems
        // eslint-disable-next-line @typescript-eslint/ban-types
        this._externals = new Map();
        this._handleRpcRequest = (request) => __awaiter(this, void 0, void 0, function* () {
            const { jobId, requestId, method, parameters } = request;
            if (this._state !== ApplicationState.Running) {
                this.emit("error", log_1.logAndReturn(this.log, new errors.Error("application is not running")));
                this._processingClient
                    .sendRpcError({
                    instanceId: this._instanceId,
                    rpcError: { jobId, requestId, method, message: "application instance was not running" },
                })
                    .catch((error) => this.emit("error", error));
                return;
            }
            const conv = this._activeConversationsByJobId.get(jobId);
            if (conv === undefined) {
                this.emit("error", log_1.logAndReturn(this.log, new errors.InternalError()));
                this._processingClient
                    .sendRpcError({
                    instanceId: this._instanceId,
                    rpcError: { jobId, requestId, method, message: "internal error" },
                })
                    .catch((error) => this.emit("error", error));
            }
            const externalHandler = this._externals.get(method);
            if (externalHandler === undefined) {
                this.emit("error", log_1.logAndReturn(this.log, new errors.ExternalNotFoundError(method)));
                this._processingClient
                    .sendRpcError({
                    instanceId: this._instanceId,
                    rpcError: {
                        jobId,
                        requestId,
                        method,
                        message: `external function ${method} not found`,
                    },
                })
                    .catch((error) => this.emit("error", error));
                return;
            }
            let result;
            try {
                result = yield externalHandler(parameters, conv);
            }
            catch (error) {
                const errorMessage = (error === null || error === void 0 ? void 0 : error.message) ? String(error.message) : String(error);
                this.log.warn(`external function error: ${errorMessage}`, error);
                this._processingClient
                    .sendRpcError({
                    instanceId: this._instanceId,
                    rpcError: { jobId, requestId, method, message: errorMessage },
                })
                    .catch((error) => this.emit("error", error));
                return;
            }
            this._processingClient
                .sendRpcResponse({
                instanceId: this._instanceId,
                rpcResponse: { jobId, requestId, method, result },
            })
                .catch((error) => this.emit("error", error));
        });
        this._handleJobTimedOut = (jobId, jobKey) => {
            this.emit("_jobTimedOut", jobId, jobKey);
        };
        this._handleJobRejected = (jobId, jobKey, jobData) => {
            this.emit("_jobRejected", jobId, jobKey, jobData);
        };
        this._handleJobStarting = (jobId, jobKey, jobData) => {
            this.emit("_jobStarting", jobId, jobKey, jobData);
        };
        this._activeConversationsByJobId = new Map();
        this._handleJobFailed = (jobId, jobKey, jobData) => {
            this._activeConversationsByJobId.delete(jobId);
            this.emit("_jobFailed", jobId, jobData);
        };
        this._handleJobCompleted = (jobId, jobKey, jobData) => {
            this._activeConversationsByJobId.delete(jobId);
            this.emit("_jobCompleted", jobId, jobData);
        };
        this._handleJobRecordIdReady = (jobId, jobKey, recordId) => {
            this.emit("_jobRecordIdReady", jobId, recordId);
        };
        this._handleJobEvent = (jobId, jobEvent) => {
            this.emit("_jobEvent", jobId, jobEvent);
        };
        //#endregion
        //#region logging
        this._handleDebugLog = (jobId, message) => {
            this.log.info(message, { jobId, label: "application" });
            this.emit("_jobDebugLog", jobId, message);
        };
        //#endregion
        //#region stt provider
        /**
         * An {@link SttDispatcher} callback that selects a speech-to-text engine
         * for all new conversations. If not set explicitly, a `"default"`
         * {@link SttProviderName | STT provider} will be used.
         */
        this.sttDispatcher = () => "default";
        //#endregion
        //#region tts provider
        /**
         * A {@link TtsDispatcher} callback that selects a text-to-speech engine
         * for all new conversations. If not set explicitly, a `"default"`
         * {@link TtsProviderName | TTS provider} will be used.
         */
        this.ttsDispatcher = () => "default";
        /**
         * A {@link CustomTtsProvider} callback to use when the {@link TtsProviderName | TTS provider}
         * is set to `"custom"` by the {@link Application.ttsDispatcher}.
         */
        this.customTtsProvider = () => {
            // imitates an error thrown by a user-supplied connection provider
            // thus, no custom errors or explicit logging here; it all happens at call site
            throw new Error("customTtsProvider was not set");
        };
        this._handleTtsRequest = (request) => __awaiter(this, void 0, void 0, function* () {
            const { requestId, messageId, text, voiceInfo } = request;
            try {
                if (this.customTtsProvider === undefined) {
                    throw new Error("no TTS provider is set");
                }
                let result = yield this.customTtsProvider(text, voiceInfo);
                // have to use duck typing since Fetch API may not be present
                if (!(result instanceof audio.Audio)) {
                    result = yield audio.fromFetchResponse(result);
                }
                yield this._externalTtsClient.sendAudioData({
                    instanceId: this._instanceId,
                    requestId,
                    messageId,
                    audio: {
                        format: result._format,
                        data: result._data,
                    },
                });
            }
            catch (error) {
                try {
                    yield this._externalTtsClient.sendAudioError({
                        instanceId: this._instanceId,
                        requestId,
                        messageId,
                        error: { type: error.name, message: error.message, details: "" },
                    });
                }
                catch (error) {
                    this.emit("error", error);
                }
                if (error instanceof errors.Error) {
                    this.emit("error", error);
                }
                else {
                    this.emit("error", log_1.logAndReturn(this.log, new errors.CustomTtsProviderError(error)));
                }
            }
        });
        //#endregion
        //#region audio client management
        this._handleAudioClientConnect = (audioClientId) => {
            const clientStream = this._processingClient.audioClientStream({ audioClientId });
            this._audioClientStreams.push(clientStream);
            clientStream.on("error", this._handleStreamError);
            clientStream.on("inviteRequest", this._handleAudioClientInviteRequest);
        };
        this._handleAudioClientInviteRequest = (audioClientId, additionalInfo, roomId) => {
            this.emit("_audioClientInviteRequest", audioClientId, additionalInfo, roomId);
        };
        //#endregion
        //#region disposable
        this._isDisposed = false;
        this.log = options.log.child({
            label: `app:${instanceId.slice(-6)}`,
            applicationId,
            instanceId,
            applicationName,
        });
        this.log.info(`applicationId: ${applicationId}`);
        this.log.info(`applicationName: ${applicationName}`);
        this.log.info(`instanceId: ${instanceId}`);
        this._applicationZip = options.applicationZip;
        this._account = options.account;
        this._reconnectTimeout = options.reconnectInterval;
        this._maxReconnectCount = options.maxReconnectCount;
        this._applicationId = applicationId;
        this._applicationName = applicationName;
        this._instanceId = instanceId;
        this._customerId = options.customerId;
        this._groupId = options.groupId;
        this._processingClient = processingClient;
        this._instanceStream = instanceStream;
        this._runtimeStream = processingClient.runtimeStream({ instanceId });
        this._debugStream = processingClient.debugStream({ instanceId });
        this._audioServerStream = processingClient.audioServerStream({ instanceId });
        this._externalTtsClient = new grpc.externalTtsProtocol.ExternalTtsClient(options.account, this.log);
        this._audioRequestStream = this._externalTtsClient.audioRequestStream({ instanceId });
        this._instanceStream.on("error", this._handleStreamError);
        this._runtimeStream.on("error", this._handleStreamError);
        this._debugStream.on("error", this._handleStreamError);
        this._audioServerStream.on("error", this._handleStreamError);
        this._audioRequestStream.on("error", this._handleStreamError);
        this._instanceStream.on("jobTimedOut", this._handleJobTimedOut);
        this._instanceStream.on("jobRejected", this._handleJobRejected);
        this._instanceStream.on("jobStarting", this._handleJobStarting);
        this._instanceStream.on("jobFailed", this._handleJobFailed);
        this._instanceStream.on("jobCompleted", this._handleJobCompleted);
        this._instanceStream.on("jobRecordIdReady", this._handleJobRecordIdReady);
        this._runtimeStream.on("rpcRequest", this._handleRpcRequest);
        this._debugStream.on("jobEvent", this._handleJobEvent);
        this._debugStream.on("debugLog", this._handleDebugLog);
        this._audioServerStream.on("connect", this._handleAudioClientConnect);
        this._audioRequestStream.on("request", this._handleTtsRequest);
        this.queue = new queue_1.ConversationQueue(this, this.log);
        this.queue.on("error", (error) => this.emit("error", error));
        this.incoming = new incoming_1.IncomingRequestManager(this, this.log);
        this.incoming.on("error", (error) => this.emit("error", error));
    }
    /** @internal */
    static _deploy(options) {
        const processingClient = new grpc.processing.ProcessingClient(options.account, options.log);
        const instanceStream = processingClient.registerInstanceStream(Object.assign(Object.assign({}, options), { concurrency: 0 }));
        return new Promise((resolve, reject) => {
            var _a;
            (_a = options.cancelToken) === null || _a === void 0 ? void 0 : _a._onCancel(options.log, (error) => {
                instanceStream.cancel();
                reject(error);
            });
            instanceStream.on("progress", ({ scopes, description, percent }) => {
                options.log.info(`${scopes.join(": ")}: ${description} ${percent}%`);
            });
            if (options.onProgress !== undefined) {
                instanceStream.on("progress", options.onProgress);
            }
            instanceStream.on("error", (error) => {
                instanceStream.cancel();
                processingClient.close();
                reject(error);
            });
            instanceStream.on("success", (applicationId, instanceId, applicationName) => {
                options.log.info("application deployed");
                instanceStream.removeAllListeners();
                resolve(new Application(options, applicationId, applicationName, instanceId, processingClient, instanceStream));
            });
        });
    }
    /**
     * Start the deployed application, enabling it to receive incoming requests
     * and run queued conversations.
     *
     * @param options.concurrency max number of conversations to run at once
     */
    start(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this._state === ApplicationState.Running) {
                log_1.logAndThrow(this.log, new errors.Error("application is already running"));
            }
            this._state = ApplicationState.Running;
            this._concurrency = (_a = options === null || options === void 0 ? void 0 : options.concurrency) !== null && _a !== void 0 ? _a : 1;
            yield this._processingClient.setInstanceConcurrency({
                instanceId: this._instanceId,
                concurrency: this._concurrency,
            });
            this.log.info(`application started with concurrency ${this._concurrency}`);
        });
    }
    /**
     * Stop the running application, disabling the creation of new conversations.
     * Conversations that are already running are unaffected.
     */
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._state !== ApplicationState.Running) {
                log_1.logAndThrow(this.log, new errors.Error("application is not running"));
            }
            this._state = ApplicationState.Stopped;
            this._concurrency = 0;
            yield this._processingClient.setInstanceConcurrency({
                instanceId: this._instanceId,
                concurrency: this._concurrency,
            });
            this.log.info("application stopped");
        });
    }
    _reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: is this okay?
            for (const jobId of this._activeConversationsByJobId.keys()) {
                this.emit("_jobFailed", jobId, { msg: "connection error" });
            }
            this._activeConversationsByJobId.clear();
            this._audioServerStream.cancel();
            for (const stream of this._audioClientStreams)
                stream.cancel();
            this._audioClientStreams = [];
            this._debugStream.cancel();
            this._runtimeStream.cancel();
            this._instanceStream.cancel();
            this._audioRequestStream.cancel();
            this.log.info(`reconnecting in ${this._reconnectTimeout} ms`);
            yield new Promise((cb) => setTimeout(cb, this._reconnectTimeout));
            this.log.info("reconnecting");
            this._instanceStream = this._processingClient.registerInstanceStream({
                applicationZip: this._applicationZip,
                concurrency: this._concurrency,
                instanceId: this._instanceId,
            });
            yield new Promise((resolve, reject) => {
                this._instanceStream.on("error", (error) => {
                    this._instanceStream.removeAllListeners();
                    reject(error);
                });
                this._instanceStream.on("success", (applicationId, instanceId) => {
                    this._instanceStream.removeAllListeners();
                    this._applicationId = applicationId;
                    this._instanceId = instanceId;
                    resolve();
                });
            });
            this._runtimeStream = this._processingClient.runtimeStream({ instanceId: this._instanceId });
            this._debugStream = this._processingClient.debugStream({ instanceId: this._instanceId });
            this._audioServerStream = this._processingClient.audioServerStream({
                instanceId: this._instanceId,
            });
            this._audioRequestStream = this._externalTtsClient.audioRequestStream({
                instanceId: this._instanceId,
            });
            this._instanceStream.on("error", this._handleStreamError);
            this._runtimeStream.on("error", this._handleStreamError);
            this._debugStream.on("error", this._handleStreamError);
            this._audioRequestStream.on("error", this._handleStreamError);
            this._instanceStream.on("jobTimedOut", this._handleJobTimedOut);
            this._instanceStream.on("jobRejected", this._handleJobRejected);
            this._instanceStream.on("jobStarting", this._handleJobStarting);
            this._instanceStream.on("jobFailed", this._handleJobFailed);
            this._instanceStream.on("jobCompleted", this._handleJobCompleted);
            this._instanceStream.on("jobRecordIdReady", this._handleJobRecordIdReady);
            this._runtimeStream.on("rpcRequest", this._handleRpcRequest);
            this._debugStream.on("jobEvent", this._handleJobEvent);
            this._debugStream.on("debugLog", this._handleDebugLog);
            this._audioServerStream.on("connect", this._handleAudioClientConnect);
            this._audioRequestStream.on("request", this._handleTtsRequest);
            this.log.info("reconnected");
        });
    }
    /** @internal */
    _executeConnectionProvider(conv) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.connectionProvider(conv);
            }
            catch (error) {
                log_1.logAndThrow(this.log, new errors.ConnectionProviderError(error));
            }
        });
    }
    /** @internal */
    _addSessionConfig(config) {
        return __awaiter(this, void 0, void 0, function* () {
            let configJson;
            try {
                configJson = JSON.stringify(config);
            }
            catch (error) {
                this.log.debug(error);
                log_1.logAndThrow(this.log, new errors.InternalError("session config is not serializable to JSON", error));
            }
            if (configJson === undefined) {
                log_1.logAndThrow(this.log, new errors.InternalError("session config is not serializable to JSON"));
            }
            const configZip = yield zip.file("config.json", configJson, this.log);
            return yield this._processingClient.addSessionConfig({
                instanceId: this._instanceId,
                configZip,
            });
        });
    }
    /**
     * Set an [external call] handler for this application.
     *
     * The handler is called with all the call arguments passed as a dictionary,
     * as well as the current {@link Conversation} object. It can return a JSON-serializable
     * value, possibly wrapped in a promise, which then is treated as the call's return value.
     * As a special case, `undefined` gets converted to `null`.
     *
     * [external call]: https://docs.dasha.ai/en-us/default/dasha-script-language/sdk-integration/#external-function
     */
    setExternal(name, fn) {
        this._externals.set(name, fn);
    }
    //#endregion
    //#region job lifecycle
    /** @internal */
    _enqueueJob(jobKey, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this._processingClient.enqueueJob({
                instanceId: this._instanceId,
                jobs: [
                    {
                        jobId: jobKey,
                        priority: options.priority,
                        after: options.after,
                        before: options.before,
                    },
                ],
            });
            return { jobId: result[0].assignedJobId };
        });
    }
    /** @internal */
    _acceptJob(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._processingClient.acceptJob(Object.assign({ instanceId: this._instanceId, jobId }, options));
        });
    }
    /** @internal */
    _rejectJob(jobId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._processingClient.rejectJob({ instanceId: this._instanceId, jobId });
        });
    }
    /** @internal */
    _bindConversation(jobId, conv) {
        this._activeConversationsByJobId.set(jobId, conv);
    }
    //#endregion
    //#region conversations
    /**
     * Create a single {@link Conversation}.
     *
     * @param input conversation's input data;
     *   can also be set later with {@link Conversation.input}
     */
    createConversation(input) {
        if (this._state !== ApplicationState.Running) {
            log_1.logAndThrow(this.log, new errors.Error("application is not running"));
        }
        return new conversation_1.SingleConversation(this, input, this.log);
    }
    /** @internal */
    _executeSttDispatcher(conv) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const providerName = yield this.sttDispatcher(conv);
                return stt._makeSttSessionConfig(providerName);
            }
            catch (error) {
                log_1.logAndThrow(this.log, new errors.SttDispatcherError(error));
            }
        });
    }
    /** @internal */
    _executeTtsDispatcher(conv) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const providerName = yield this.ttsDispatcher(conv);
                return tts._makeTtsSessionConfig(providerName);
            }
            catch (error) {
                log_1.logAndThrow(this.log, new errors.TtsDispatcherError(error));
            }
        });
    }
    /** @internal */
    _getAudioClientEndpoint(audioClientId, roomId) {
        return JSON.stringify({
            roomId,
            type: "grpc",
            customerId: this._customerId,
            applicationName: this._applicationName,
            groupId: this._groupId,
            otherAudioClientIds: [audioClientId],
        });
    }
    // TODO: audio client docs
    /**
     * Get the authorization token for [audio client] applications.
     */
    getAudioClientToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const api = new rest.MiscApi(this._account, this.log);
            return yield api.getAudioClientAuthToken({
                customerId: this._customerId,
                applicationName: this._applicationName,
                groupId: this._groupId,
            });
        });
    }
    //#endregion
    //#region call recordings
    /** @internal */
    _getRecordingUrl(callId) {
        return `${account_1.getBaseHttpUrl(this._account)}/api/v1/records/${callId}`;
    }
    /**
     * Close the connection with the application, freeing all local resources.
     */
    dispose() {
        if (this._isDisposed)
            return;
        this._isDisposed = true;
        this.queue._dispose();
        this.incoming._dispose();
        this._audioRequestStream.cancel();
        this._externalTtsClient.close();
        this._audioServerStream.cancel();
        for (const stream of this._audioClientStreams)
            stream.cancel();
        this._debugStream.cancel();
        this._runtimeStream.cancel();
        this._instanceStream.cancel();
        this._processingClient.close();
        this.removeAllListeners();
        this.log.info("application disposed of");
    }
}
exports.Application = Application;
//# sourceMappingURL=application.js.map