"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessingClient = exports.JobStatus = void 0;
const base = require("./base");
const errors = require("../errors");
const log_1 = require("../log");
const sdk_grpc_pb = require("./generated/sdk_grpc_pb");
const sdk_pb = require("./generated/sdk_pb");
var JobStatus;
(function (JobStatus) {
    JobStatus[JobStatus["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    JobStatus[JobStatus["STARTING"] = 1] = "STARTING";
    JobStatus[JobStatus["TIMED_OUT"] = 2] = "TIMED_OUT";
    JobStatus[JobStatus["FAILED"] = 3] = "FAILED";
    JobStatus[JobStatus["COMPLETED"] = 4] = "COMPLETED";
    JobStatus[JobStatus["REJECTED"] = 5] = "REJECTED";
    JobStatus[JobStatus["READY_DEBUG_LOG"] = 6] = "READY_DEBUG_LOG";
    JobStatus[JobStatus["READY_RECORD_ID"] = 7] = "READY_RECORD_ID";
})(JobStatus = exports.JobStatus || (exports.JobStatus = {}));
class ProcessingClient extends base.Client {
    constructor(account, log) {
        super(sdk_grpc_pb.ProcessingClient, account, log);
    }
    registerInstanceStream(request) {
        return new base.Stream((stream) => {
            const grpcRequest = new sdk_pb.RegisterRequest();
            grpcRequest.setApp(request.applicationZip);
            grpcRequest.setConcurrency(request.concurrency);
            if (request.groupId !== undefined)
                grpcRequest.setGroupid(request.groupId);
            if (request.sdkVersion !== undefined)
                grpcRequest.setSdkVersion(request.sdkVersion);
            if (request.instanceId !== undefined)
                grpcRequest.setInstanceId(request.instanceId);
            const grpcStream = this.grpcClient.registerInstanceStream(grpcRequest);
            grpcStream.on("error", (grpcError) => {
                stream.emit("error", this.wrapGrpcError(grpcError));
                stream.cancel();
            });
            grpcStream.on("end", () => {
                stream.removeAllListeners();
            });
            grpcStream.on("data", (grpcMessage) => {
                const { error, success, progress, jobNotification } = grpcMessage.toObject();
                if (error !== undefined) {
                    stream.emit("error", log_1.logAndReturn(this.log, new errors.DeploymentError(error.errorCode, error.errorDetails)));
                    stream.cancel();
                }
                if (success !== undefined) {
                    stream.emit("success", success.appId, success.instanceId, success.applicationName);
                }
                if (progress !== undefined) {
                    stream.emit("progress", {
                        percent: progress.percent,
                        description: progress.stageDescription,
                        scopes: progress.stageScopeList,
                    });
                }
                if (jobNotification !== undefined) {
                    let parsedData;
                    try {
                        parsedData = JSON.parse(jobNotification === null || jobNotification === void 0 ? void 0 : jobNotification.data);
                    }
                    catch (error) {
                        this.log.debug(error);
                        stream.emit("error", log_1.logAndReturn(this.log, new errors.InternalError("JobNotification.data was not valid JSON", error)));
                        stream.cancel();
                        return;
                    }
                    if (jobNotification.status === JobStatus.TIMED_OUT) {
                        stream.emit("jobTimedOut", jobNotification.assignedJobId, jobNotification.customerJobId);
                    }
                    if (jobNotification.status === JobStatus.REJECTED) {
                        stream.emit("jobRejected", jobNotification.assignedJobId, jobNotification.customerJobId, parsedData);
                    }
                    if (jobNotification.status === JobStatus.STARTING) {
                        stream.emit("jobStarting", jobNotification.assignedJobId, jobNotification.customerJobId, parsedData);
                    }
                    if (jobNotification.status === JobStatus.FAILED) {
                        stream.emit("jobFailed", jobNotification.assignedJobId, jobNotification.customerJobId, parsedData);
                    }
                    if (jobNotification.status === JobStatus.COMPLETED) {
                        stream.emit("jobCompleted", jobNotification.assignedJobId, jobNotification.customerJobId, parsedData);
                    }
                    if (jobNotification.status === JobStatus.READY_RECORD_ID) {
                        if (typeof parsedData.recordId !== "string")
                            throw new errors.InternalError();
                        stream.emit("jobRecordIdReady", jobNotification.assignedJobId, jobNotification.customerJobId, parsedData.recordId);
                    }
                }
            });
            return grpcStream;
        });
    }
    setInstanceConcurrency(request) {
        return new Promise((resolve, reject) => {
            const grpcRequest = new sdk_pb.InstanceConcurrencySetRequest()
                .setInstanceId(request.instanceId)
                .setNewConcurrency(request.concurrency);
            this.grpcClient.setInstanceConcurrency(grpcRequest, (grpcError) => {
                if (grpcError) {
                    reject(this.wrapGrpcError(grpcError));
                }
                resolve();
            });
        });
    }
    addSessionConfig(request) {
        return new Promise((resolve, reject) => {
            const grpcRequest = new sdk_pb.AddSessionConfigRequest();
            grpcRequest.setInstanceId(request.instanceId);
            grpcRequest.setConfig(request.configZip);
            if (request.configName !== undefined)
                grpcRequest.setConfigName(request.configName);
            this.grpcClient.addSessionConfig(grpcRequest, (grpcError, grpcResponse) => {
                if (grpcError) {
                    reject(this.wrapGrpcError(grpcError));
                    return;
                }
                resolve(grpcResponse.toObject());
            });
        });
    }
    runtimeStream(request) {
        return new base.Stream((stream) => {
            const grpcRequest = new sdk_pb.StreamInit();
            grpcRequest.setInstanceId(request.instanceId);
            const grpcStream = this.grpcClient.runtimeStream(grpcRequest);
            grpcStream.on("error", (grpcError) => {
                stream.emit("error", this.wrapGrpcError(grpcError));
                stream.cancel();
            });
            grpcStream.on("end", () => {
                grpcStream.removeAllListeners();
                stream.removeAllListeners();
            });
            grpcStream.on("data", (grpcMessage) => {
                const { request } = grpcMessage.toObject();
                if (request !== undefined) {
                    const parsedParameters = {};
                    for (const { name, value } of request.parametersList) {
                        try {
                            parsedParameters[name] = JSON.parse(value);
                        }
                        catch (error) {
                            this.log.debug(error);
                            stream.emit("error", log_1.logAndReturn(this.log, new errors.InternalError(`parameter ${name} was not valid JSON`, error)));
                            return;
                        }
                    }
                    if (request.method.startsWith("graphCall/")) {
                        stream.emit("rpcRequest", {
                            jobId: request.jobId,
                            requestId: request.requestId,
                            method: request.method.slice("graphCall/".length),
                            parameters: parsedParameters,
                        });
                    }
                }
            });
            return grpcStream;
        });
    }
    debugStream(request) {
        return new base.Stream((stream) => {
            const grpcRequest = new sdk_pb.StreamInit();
            grpcRequest.setInstanceId(request.instanceId);
            const grpcStream = this.grpcClient.debugStream(grpcRequest);
            grpcStream.on("error", (grpcError) => {
                stream.emit("error", this.wrapGrpcError(grpcError));
                stream.cancel();
            });
            grpcStream.on("end", () => {
                grpcStream.removeAllListeners();
                stream.removeAllListeners();
            });
            grpcStream.on("data", (grpcMessage) => {
                const { notification } = grpcMessage.toObject();
                if (notification !== undefined) {
                    const parsedParameters = {};
                    for (const { name, value } of notification.parametersList) {
                        try {
                            parsedParameters[name] = JSON.parse(value);
                        }
                        catch (error) {
                            this.log.debug(error);
                            stream.emit("error", log_1.logAndReturn(this.log, new errors.InternalError(`parameter ${name} was not valid JSON`, error)));
                            return;
                        }
                    }
                    if (notification.method === "jobEvent") {
                        stream.emit("jobEvent", notification.jobId, parsedParameters.content);
                    }
                    if (notification.method === "debugLog") {
                        stream.emit("debugLog", notification.jobId, String(parsedParameters.message));
                    }
                }
            });
            return grpcStream;
        });
    }
    acceptJob(request) {
        return new Promise((resolve, reject) => {
            var _a;
            let jsonData;
            try {
                jsonData = JSON.stringify((_a = request.data) !== null && _a !== void 0 ? _a : {});
            }
            catch (error) {
                this.log.debug(error);
                log_1.logAndThrow(this.log, new errors.InternalError("request.data not serializable to JSON", error));
            }
            if (jsonData === undefined) {
                log_1.logAndThrow(this.log, new errors.InternalError("request.data is undefined"));
            }
            const grpcRequest = new sdk_pb.AcceptJobMessage();
            grpcRequest.setInstanceId(request.instanceId);
            grpcRequest.setJobId(request.jobId);
            grpcRequest.setSessionConfigName(request.sessionConfigName);
            grpcRequest.setData(jsonData);
            this.grpcClient.acceptJob(grpcRequest, (grpcError) => {
                if (grpcError) {
                    reject(this.wrapGrpcError(grpcError));
                    return;
                }
                resolve();
            });
        });
    }
    rejectJob(request) {
        return new Promise((resolve, reject) => {
            const grpcRequest = new sdk_pb.RejectJobMessage();
            grpcRequest.setInstanceId(request.instanceId);
            grpcRequest.setJobId(request.jobId);
            this.grpcClient.rejectJob(grpcRequest, (grpcError) => {
                if (grpcError) {
                    reject(this.wrapGrpcError(grpcError));
                    return;
                }
                resolve();
            });
        });
    }
    enqueueJob(request) {
        return new Promise((resolve, reject) => {
            const grpcRequest = new sdk_pb.EnqueueJobRequest();
            grpcRequest.setInstanceId(request.instanceId);
            grpcRequest.setJobsList(request.jobs.map((job) => new sdk_pb.JobDescription()
                .setJobId(job.jobId)
                .setPriority(job.priority)
                .setNotBefore(Math.trunc(job.after.getTime() / 1000))
                .setNotAfter(Math.trunc(job.before.getTime() / 1000))));
            this.grpcClient.enqueueJob(grpcRequest, (grpcError, grpcResponse) => {
                if (grpcError) {
                    reject(this.wrapGrpcError(grpcError));
                    return;
                }
                const { jobsList } = grpcResponse.toObject();
                resolve(jobsList);
            });
        });
    }
    sendRpcResponse(request) {
        return new Promise((resolve, reject) => {
            var _a;
            const { instanceId, rpcResponse } = request;
            const grpcRequest = new sdk_pb.ClientStreamMessage();
            grpcRequest.setInstanceId(instanceId);
            let jsonResult;
            try {
                jsonResult = JSON.stringify((_a = rpcResponse.result) !== null && _a !== void 0 ? _a : null);
            }
            catch (error) {
                reject(log_1.logAndReturn(this.log, new errors.ExternalResultNotSerializableError(rpcResponse.method)));
                return;
            }
            const streamResponse = new sdk_pb.StreamResponse();
            streamResponse.setJobId(rpcResponse.jobId);
            streamResponse.setRequestId(rpcResponse.requestId);
            streamResponse.setResult(jsonResult);
            grpcRequest.setMessage(new sdk_pb.StreamMessage().setResponse(streamResponse));
            this.grpcClient.sendRuntimeMessage(grpcRequest, (grpcError) => {
                if (grpcError) {
                    reject(this.wrapGrpcError(grpcError));
                    return;
                }
                resolve();
            });
        });
    }
    sendRpcError(request) {
        return new Promise((resolve, reject) => {
            const { instanceId, rpcError } = request;
            const grpcRequest = new sdk_pb.ClientStreamMessage();
            grpcRequest.setInstanceId(instanceId);
            const streamError = new sdk_pb.StreamError();
            streamError.setJobId(rpcError.jobId);
            streamError.setRequestId(rpcError.requestId);
            streamError.setMessage(rpcError.message);
            grpcRequest.setMessage(new sdk_pb.StreamMessage().setError(streamError));
            this.grpcClient.sendRuntimeMessage(grpcRequest, (grpcError) => {
                if (grpcError) {
                    reject(this.wrapGrpcError(grpcError));
                    return;
                }
                resolve();
            });
        });
    }
    audioServerStream(request) {
        return new base.Stream((stream) => {
            const grpcRequest = new sdk_pb.AudioClientStreamRequest();
            grpcRequest.setInstanceId(request.instanceId);
            const grpcStream = this.grpcClient.listenForAudioClients(grpcRequest);
            grpcStream.on("error", (grpcError) => {
                stream.emit("error", this.wrapGrpcError(grpcError));
                stream.cancel();
            });
            grpcStream.on("end", () => {
                grpcStream.removeAllListeners();
                stream.removeAllListeners();
            });
            grpcStream.on("data", (grpcMessage) => {
                const { audioClientId, additionalInfo } = grpcMessage.toObject();
                stream.emit("connect", audioClientId, additionalInfo);
            });
            return grpcStream;
        });
    }
    audioClientStream(request) {
        return new base.Stream((stream) => {
            const grpcRequest = new sdk_pb.AudioClientConnectionRequest();
            grpcRequest.setAudioClientId(request.audioClientId);
            const grpcStream = this.grpcClient.audioClientStateStream(grpcRequest);
            grpcStream.on("error", (grpcError) => {
                stream.emit("error", this.wrapGrpcError(grpcError));
                stream.cancel();
            });
            grpcStream.on("end", () => {
                grpcStream.removeAllListeners();
                stream.removeAllListeners();
            });
            grpcStream.on("data", (grpcMessage) => {
                const { requestType, roomId, audioClientId, additionalInfo } = grpcMessage.toObject();
                const RequestType = sdk_pb.AudioClientMessage.AudioClientMessageType;
                if (requestType === RequestType.INVITE) {
                    stream.emit("inviteRequest", audioClientId, additionalInfo, roomId || undefined);
                }
            });
            return grpcStream;
        });
    }
}
exports.ProcessingClient = ProcessingClient;
//# sourceMappingURL=processing.js.map