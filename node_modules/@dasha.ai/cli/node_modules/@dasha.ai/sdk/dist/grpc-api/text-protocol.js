"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextProtocolClient = void 0;
const base = require("./base");
const sdk_grpc_pb = require("./generated/sdk_grpc_pb");
const sdk_pb = require("./generated/sdk_pb");
class TextProtocolClient extends base.Client {
    constructor(account, log) {
        super(sdk_grpc_pb.TextProtocolClient, account, log);
    }
    sendText(request) {
        return new Promise((resolve, reject) => {
            const { jobId, text } = request;
            const grpcRequest = new sdk_pb.TextProtocolMessage();
            grpcRequest.setJobId(jobId);
            grpcRequest.setText(new sdk_pb.TextMessage().setText(text));
            this.grpcClient.sendMessage(grpcRequest, (grpcError) => {
                if (grpcError) {
                    reject(this.wrapGrpcError(grpcError));
                    return;
                }
                resolve();
            });
        });
    }
    sendClose(request) {
        return new Promise((resolve, reject) => {
            const { jobId } = request;
            const grpcRequest = new sdk_pb.TextProtocolMessage();
            grpcRequest.setJobId(jobId);
            grpcRequest.setClosed(new sdk_pb.ClosedSessionMessage());
            this.grpcClient.sendMessage(grpcRequest, (grpcError) => {
                if (grpcError) {
                    reject(this.wrapGrpcError(grpcError));
                    return;
                }
                resolve();
            });
        });
    }
    messageStream(request) {
        return new base.Stream((stream) => {
            const grpcRequest = new sdk_pb.TextProtocolStreamInit();
            grpcRequest.setJobId(request.jobId);
            const grpcStream = this.grpcClient.messageStream(grpcRequest);
            grpcStream.on("error", (grpcError) => {
                stream.emit("error", this.wrapGrpcError(grpcError));
                stream.cancel();
            });
            grpcStream.on("end", () => {
                grpcStream.removeAllListeners();
                stream.removeAllListeners();
            });
            grpcStream.on("data", (grpcMessage) => {
                const { jobId, text, closed } = grpcMessage.toObject();
                if (text !== undefined) {
                    stream.emit("text", jobId, text.text);
                }
                if (closed !== undefined) {
                    stream.emit("close", jobId);
                }
            });
            return grpcStream;
        });
    }
}
exports.TextProtocolClient = TextProtocolClient;
//# sourceMappingURL=text-protocol.js.map