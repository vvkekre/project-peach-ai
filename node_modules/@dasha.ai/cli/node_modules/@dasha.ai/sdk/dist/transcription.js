"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TranscriptionParser = void 0;
const EventEmitter = require("eventemitter3");
const isObject = (x) => typeof x === "object" && x !== null;
/** @internal */
class TranscriptionParser extends EventEmitter {
    constructor() {
        super(...arguments);
        this._outgoing = { state: "initial" };
        this._incomingVoiceSegments = new Map();
    }
    push(jobEvent) {
        if (!isObject(jobEvent))
            return;
        if (typeof jobEvent.time !== "string")
            return;
        const { msg } = jobEvent;
        if (!isObject(msg))
            return;
        if ("voiceSegmentId" in msg) {
            const state = this._incomingVoiceSegments.get(msg.voiceSegmentId);
            switch (state === null || state === void 0 ? void 0 : state.state) {
                case undefined:
                    if (msg.msgId === "SpeechChannelMessage" && msg.type === "Voice") {
                        this._incomingVoiceSegments.set(msg.voiceSegmentId, {
                            state: "voice",
                            startTime: new Date(jobEvent.time),
                        });
                    }
                    break;
                case "voice":
                    if (msg.textMsgId === "FinalTextChannelMessage") {
                        this._incomingVoiceSegments.set(msg.voiceSegmentId, {
                            state: "final",
                            startTime: state.startTime,
                            text: String(msg.text),
                        });
                    }
                    if (msg.msgId === "SpeechChannelMessage" && msg.type === "Pause") {
                        this._incomingVoiceSegments.set(msg.voiceSegmentId, {
                            state: "pause",
                            startTime: state.startTime,
                            endTime: new Date(jobEvent.time),
                        });
                    }
                    break;
                case "final":
                    if (msg.msgId === "SpeechChannelMessage" && msg.type === "Pause") {
                        this._incomingVoiceSegments.delete(msg.voiceSegmentId);
                        this.emit("transcription", {
                            speaker: "human",
                            text: state.text,
                            startTime: state.startTime,
                            endTime: new Date(jobEvent.time),
                        });
                    }
                    break;
                case "pause":
                    if (msg.textMsgId === "ConfidentTextChannelMessage") {
                        this._incomingVoiceSegments.delete(msg.voiceSegmentId);
                        this.emit("transcription", {
                            speaker: "human",
                            text: String(msg.text),
                            startTime: state.startTime,
                            endTime: state.endTime,
                        });
                    }
                    break;
            }
        }
        switch (this._outgoing.state) {
            case "initial":
                if (msg.msgId === "RawTextChannelMessage" && jobEvent.incoming === false) {
                    this._outgoing = {
                        state: "text",
                        text: String(msg.text),
                        startTime: new Date(jobEvent.time),
                    };
                }
                break;
            case "text":
                if (msg.msgId === "StoppedPlayingAudioChannelMessage") {
                    this.emit("transcription", {
                        speaker: "ai",
                        text: this._outgoing.text,
                        startTime: this._outgoing.startTime,
                        endTime: new Date(jobEvent.time),
                    });
                    this._outgoing = { state: "initial" };
                }
                break;
        }
    }
    dispose() {
        this.removeAllListeners();
    }
}
exports.TranscriptionParser = TranscriptionParser;
//# sourceMappingURL=transcription.js.map